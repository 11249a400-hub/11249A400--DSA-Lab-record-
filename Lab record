# 11249A400--DSA-Lab-record-

Experiment 1:
LINEAR SEARCH 

Aim:
To write a program to search for a given element in a list (or array) using the Linear Search technique.

Algorithm:
1.Start
2. Input the number of elements in the array.
3. Read all the elements of the array.
4. Input the element to be searched (key).
5. Set a flag variable (e.g., found = 0).
6. Repeat from index i = 0 to n - 1:
If array[i] == key, then
Set found = 1
7.Print “Element found at position i+1”
8.Stop the search.

CODE:
#include <stdio.h>

int main() {
    int n, i, key, found = 0;
    
    printf("Enter the size of array: ");
    scanf("%d", &n);
  int A[n]
    
    printf("Enter./.d the elements of the array: ");
    for (i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    
    printf("Enter the element to search: ");
    scanf("%d", &key);
    
    for (i = 0; i < n; i++) {
        if (a[i] == key) {
            printf("Element found at position %d\n", i + 1);
            found = 1;
            break;
        }
    }
    
    if (!found) {
        printf("Element not found in the array.\n");
    }
    
    return 0;
}

INPUT:
Enter number of elements: 5
Enter elements: 10 20 30 40 50
Enter element to search: 30

OUTPUT:
Element found at position 3

RESULT:
Thus, the program to search for a given element using the Linear Search technique was successfully executed and verified.

EXPERIMENT:2
Binary

AIM:
To write a program to search for a given element in an array using the Binary Search technique.

ALGORITHM:
1. Start the program.
2. Initialize an array of sorted elements.
3. Read the number of elements, n.
4. Read the n sorted elements into the array.
5. Read the element to be searched, say key.
6. Initialize two variables:
low = 0
high = n - 1
7. Repeat the following steps while low <= high:
Find the middle index: mid = (low + high) // 2
If array[mid] == key, then
Print “Element found at position mid + 1”
Stop the search.
Else if array[mid] > key, the,
Set high = mid - 1,
Else
Set low = mid + 1.
8. If the element is not found, print “Element not found”.
9. Stop the program.

CODE:
#include <stdio.h>

int main() {
    int A[] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    int n = sizeof(A) / sizeof(A[0]);
    int low = 0;
    int high = n - 1;
    int key;
    int found = 0;

    printf("Enter the element to search: ");
    scanf("%d", &key);

    while (low <= high) {
        int mid = (low + high) / 2;
        if (A[mid] == key) {
            printf("Element found at position: %d\n", mid + 1);
            found = 1;
            break;
        } else if (A[mid] < key) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    if (!found) {
        printf("Element not found in the array.\n");
    }

    return 0;
}

INPUT:
Enter number of elements: 5
Enter sorted elements: 10 20 30 40 50
Enter element to search: 40

OUTPUT:
Element not found 

RESULT:
Thus, the program to search for a given element using the Binary Search technique was successfully executed and verified.

EXPERIMENT 3
stack

AIM:
To write a program to implement Stack operations such as Push, Pop, and Display using an array.

ALGORITHM:
1.Start the program.
2. Initialize an empty stack and set top = -1.
3. Display menu with the following operations:
1. Push
2. Pop
3. Display
4. Exit
4. For Push operation:
If top == MAX - 1, print “Stack Overflow”.
Else, increment top by 1 and insert the new element at stack[top].
5. For Pop operation:If top == -1, print “Stack Underflow”.
Else, print the deleted element stack[top] and decrement top by 1.
6. For Display operation:
If top == -1, print “Stack is empty”.
Else, print all elements from top to 0.
7. Repeat steps 3–6 until the user selects Exit.
8. Stop the program.

CODE:
#include <stdio.h>
#include <stdlib.h>

#define SIZE 100

int stack[SIZE];
int top = -1;
choice,item,stack[top]

void push(int item) {
    if (top == SIZE - 1) {
        printf("Stack Overflow\n");
    } else {
        top++;
        stack[top] = item;
    }
}

int pop() {
    if (top == -1) {
        printf("Stack Underflow\n");
        return -1; // Or some other error indicator
    } else {
        int item = stack[top];
        top--;
        return item;
    }
}

void display() {
    if (top == -1) {
        printf("Stack is empty\n");
    } else {
        printf("Stack elements are:\n");
        for (int i = top; i >= 0; i--) {
            printf("%d\n", stack[i]);
        }
    }
}

int main() {
    int choice, item;

    while (1) {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Display\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the value to push: ");
                scanf("%d", &item);
                push(item);
                break;
            case 2:
                item = pop();
                if (item != -1) {
                    printf("Popped item is: %d\n", item);
                }
                break;
            
             case 3:
                exit(0);
            default:
                printf("Incorrct option");
          break;
        }
    }
    return 0;
}

INPUT:
enter the stack :3
1.push
2.pop
3.exit
chise your option 2
stack is underflow
1
1
1
1

RESULT:
Thus, the program to implement Stack operations (Push, Pop, and Display) using an array was successfully executed and verified

EXPERIMENT 4
REVERSE STRING USING STACK 

AIM:
To write a program that reverses a given string using the stack data structure.

ALGORITHM:
1. Start
2. Initialize an empty stack.
3. Input the string to be reversed.
4. Push each character of the string onto the stack one by one.
5. Pop each character from the stack and append it to a new string.
Since the stack works on the LIFO (Last In, First Out) principle, popping characters will give the reversed order.
6. Display the reversed string.
7. Stop

CODE:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100

char STACK[MAX];
int TOP = -1;

void push(char item) {
print (" there are./.d elements in stack./n",top+1);
for(int i=top; i>=0;i++)
{
    if (TOP == MAX - 1) {
        printf("Stack is overflow\n");
    } else {
        TOP = TOP + 1;
        STACK[TOP] = item;
    }
}

char pop() {
    if (TOP == -1) {
        printf("Stack is underflow\n");
        return '\0';
    } else {
        char item = STACK[TOP];
        TOP = TOP - 1;
        return item;
    }
}

void display() {
    if (TOP == -1) {
        printf("Stack is empty\n");
char pop()
{
char item;
if(top==-1)
{
printf(" stack is inder flow/ empty/n")
return\0:
    } 
else
{
       printf("There are %d elements in stack:\n", TOP + 1);
        for (int i = TOP; i >= 0; i--) {
            printf("%c\n", STACK[i]);
        }
    }
}

int main() {
    char str[MAX];
    printf("Enter a string: ");
    gets(str);

    int i;
    for (i = 0; i < strlen(str); i++) {
        push(str[i]);
    }

    printf("Reversed string: ");
    while (TOP != -1) {
        printf("%c", pop());
    }
    printf("\n");

    return 0;
}

INPUT:
Enter a string: HELLO

OUTPUT:
Reversed string: OLLEH

RESULT:
The program successfully reverses a given string using a stack by utilizing the LIFO principle.

EXPERIMENT 5
INFIX TO POST FIX 

AIM:
Convert a given arithmetic expression in infix notation (operators between operands, e.g. A + B * C) 
into its equivalent postfix notation (operators after operands, e.g. A B C * +) so it can be evaluated easily by a stack-based evaluator.

ALGORITHM:
1. Initialize an empty stack S and an empty output string out.
2. Scan the infix expression from left to right token by token (operand, operator, parenthesis).
3. For each token:
Operand (variable/number): append it to out.
Left parenthesis (: push it onto S.
Right parenthesis ): pop from S and append to out until you pop a ( (discard both parentheses).
Operator (op):
While S is not empty and the operator at the top of S has higher precedence OR same precedence and left-associative, and the top is not (, pop it and append to out.
Push the current operator op onto S.
4. After the input is fully read, pop any remaining operators from S and append to out.
5. out is the final postfix expression.

CODE:
# Function to define precedence of operators
def precedence(op):
    if op == '+' or op == '-':
        return 1
    if op == '*' or op == '/':
        return 2
    if op == '^':
        return 3
    return 0

# Function to check if character is operand
def is_operand(ch):
    return ch.isalnum()

# Function to convert infix to postfix
def infix_to_postfix(expression):
    stack = []    # for operators
    output = []   # for result

    for ch in expression:
        # If operand, add to output
        if is_operand(ch):
            output.append(ch)
        # If '(', push to stack
        elif ch == '(':
            stack.append(ch)
        # If ')', pop until '('
        elif ch == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop()  # Remove '('
        # Operator
        else:
            while (stack and precedence(stack[-1]) >= precedence(ch)):
                output.append(stack.pop())
            stack.append(ch)

    # Pop all remaining operators
    while stack:
        output.append(stack.pop())

    return "".join(output)

# ---- Main Program ----
exp = input("Enter infix expression: ")
print("Postfix expression:", infix_to_postfix(exp))

INPUT:
Enter infix expression: (A+B)*C-D^E^F

OUTPUT:
Postfix expression: AB+C*DEF^^-

RESULT:
Step 1: (A+B) → AB+
Step 2: (AB+)*C → AB+C*
Step 3: (AB+C*)-D^E^F → AB+C*DEF^^-
Hence, the equivalent postfix expression for (A+B)*C-D^E^F is AB+C*DEF^^-.

Experiment 6










